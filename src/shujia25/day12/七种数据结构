1、栈
    栈（Stack）是一种线性数据结构，它遵循后进先出（Last-In-First-Out，LIFO）的原则。
    栈的特点是只允许在一端进行插入和删除操作，该端被称为栈顶，另一端被称为栈底。

    栈的基本操作包括入栈（push）和出栈（pop）：
        - 入栈（push）：将元素添加到栈顶。
        - 出栈（pop）：从栈顶移除元素，并返回移除的元素。

    栈的操作遵循以下原则：
        - 后进先出（LIFO）：最后入栈的元素最先出栈。
        - 只能在栈顶进行插入和删除操作。
        - 不支持随机访问，只能按照入栈顺序逐个访问栈中的元素。
        - 栈的大小有限，当栈满时无法再进行入栈操作。

    栈常用于解决一些具有后进先出特性的问题，例如：
        - 表达式求值：利用栈来实现表达式的计算顺序，其中运算符和操作数依次入栈并按照规则进行计算。
        - 函数调用跟踪：用栈来保存函数的调用信息，包括返回地址、局部变量等，以便于函数调用的嵌套和返回操作的处理。
        - 括号匹配：通过栈来判断括号是否匹配，可以用于验证括号的闭合情况。

    在Java中，栈可以通过使用内置的数据结构数组或链表来实现。
    Java提供了`Stack`类，它是`Vector`类的一个子类，实现了栈的基本功能。`Stack`类提供了入栈、出栈、获取栈顶元素、判断栈是否为空等方法。
    除了使用`Stack`类，我们也可以使用`LinkedList`类或自定义的数据结构来实现栈。
    使用链表来实现栈可以更灵活地处理栈的大小问题，而不受固定大小的限制。


2、队列：
    队列（Queue）是一种线性数据结构，它遵循先进先出（First-In-First-Out，FIFO）的原则。
    队列的特点是只允许在一端进行插入操作，称为队尾，而在另一端进行删除操作，称为队首。

    队列的基本操作包括入队（enqueue）和出队（dequeue）：
        - 入队（enqueue）：将元素添加到队尾。
        - 出队（dequeue）：从队首移除元素，并返回移除的元素。

    队列的操作遵循以下原则：
        - 先进先出（FIFO）：最先入队的元素最先出队。
        - 元素的插入操作只能在队尾进行。
        - 元素的删除操作只能在队首进行。
        - 不支持随机访问，只能按照入队顺序逐个访问队列中的元素。

    队列常用于解决一些具有先进先出特性的问题，例如：
        - 任务调度：利用队列实现任务的排队，按照先来先服务的顺序进行处理。
        - 缓存管理：利用队列来管理缓存，最先进入队列的数据最先被使用或移除。
        - 消息传递：用队列来存储和传递消息，确保消息按照先后顺序被处理。

    在Java中，队列可以通过使用内置的数据结构数组、链表或双端队列来实现。
    Java提供了`Queue`接口作为队列的抽象，它定义了队列的基本操作，如入队、出队、获取队首元素等。常用的实现类包括`LinkedList`、`ArrayDeque`等。
    除了基本的队列操作，还有一些特殊类型的队列，如优先队列（PriorityQueue）和阻塞队列（BlockingQueue）。
    优先队列根据元素的优先级进行排序，每次出队操作都返回优先级最高的元素。阻塞队列支持阻塞操作，可以实现线程间的同步和协作。


3、数组
    数组是一种线性数据结构，它是由一组相同类型的元素按照一定顺序排列而成的集合。数组的特点包括：
        随机访问：通过索引可以直接访问数组中的元素，时间复杂度为O(1)。这是因为数组在内存中是连续存储的，通过索引可以计算出元素的地址，从而直接访问。
        长度固定：数组一旦创建后，其长度是固定的，无法动态改变。因此，在使用数组时需要提前确定数组的长度。
        同一类型元素：数组中的所有元素必须是相同类型的，可以是基本数据类型或引用类型。
        连续存储：数组中的元素在内存中是连续存储的，这也是实现随机访问的基础。
    查询快，增删慢


4、链表
    链表是一种常见的数据结构，它由一系列节点组成，每个节点包含两部分：数据(数据域)和指向下一个节点的引用(指针域)。
    链表中的节点通过这些引用连接在一起，形成了一个链式的数据结构。

    链表的特点包括：
        1. 动态性：链表的长度是可以动态变化的，可以方便地进行插入和删除操作，而不需要像数组那样需要进行元素的移动。
        2. 不连续存储：链表中的节点在内存中不必连续存储，每个节点可以存储在不同的内存块中，它们通过指针相互连接。
        3. 节省空间：相比数组，链表不需要预先分配一块连续的内存空间，可以根据需要动态地分配节点，节省了空间。

    链表常见的类型包括单链表、双链表和循环链表：
        1. 单链表（Singly Linked List）：每个节点只包含下一个节点的引用，最后一个节点的引用为空。从头节点开始，通过每个节点的引用可以遍历整个链表。
        2. 双链表（Doubly Linked List）：每个节点包含前一个节点和后一个节点的引用。双链表可以双向遍历，即可以从头节点向后遍历，也可以从尾节点向前遍历。
        3. 循环链表（Circular Linked List）：在单链表或双链表的基础上，尾节点的引用指向头节点，形成一个环状结构。

    链表的常见操作包括：
        1. 添加元素：
           - 在链表头部添加元素：创建新节点，并将其指向当前头节点，然后将头节点指向新节点。
           - 在链表尾部添加元素：遍历链表，找到尾节点，创建新节点，并将尾节点的引用指向新节点。
           - 在指定位置添加元素：遍历链表，找到指定位置的节点，创建新节点，并将新节点的引用指向后继节点，再将前驱节点的引用指向新节点。
        2. 删除元素：
           - 删除链表头部元素：将头节点的引用指向下一个节点，删除原始头节点。
           - 删除链表尾部元素：遍历链表，找到尾节点的前驱节点，将前驱节点的引用置空，删除尾节点。
           - 删除指定位置的元素：遍历链表，找到指定位置的前驱节点，将前驱节点的引用指向后继节点，删除指定节点。
        3. 查找元素：
           - 遍历链表，逐个比较节点的值，找到目标元素。
           - 可以根据具体需求，实现按索引查找、按特定条件查找等功能。
        4. 修改元素：
           - 遍历链表，找到指定位置或目标元素，修改节点的值。


5、树
    树（Tree）是一种非线性的数据结构，它由一组节点组成，并通过节点之间的连接关系构成层次结构。
    树的基本结构由根节点、子节点和父节点组成，根节点是树的顶部节点，子节点是根节点的直接后代节点，父节点是一个节点的直接上级节点。

    常见的存储方式：
        左<根<右

    二叉树的取值方式(遍历方式)：
        1、前序遍历 (根左右)
        2、中序遍历 (左根右) 常见存储方式的顺序遍历
        3、后序遍历 (左右根)


    树的特点包括：
        1. 层次结构：树中的节点通过连接关系形成层次结构，从根节点开始，每个节点可以有多个子节点，每个子节点又可以有自己的子节点，形成多层嵌套的结构。
        2. 唯一根节点：每棵树有且只有一个根节点，它是树的起始点，所有其他节点都通过直接或间接的连接关系与根节点相连。
        3. 分支与叶子节点：除了根节点外，每个节点可以有多个子节点，被称为分支节点。没有子节点的节点被称为叶子节点，它们位于树的最底部。
        4. 无环结构：树中不存在回路或环路，即任意两个节点之间只能有唯一的路径连接，没有重复的连接。

    树的常见类型包括二叉树、二叉搜索树、平衡树、红黑树、B树和堆等。
        1. 二叉树（Binary Tree）：每个节点最多有两个子节点，分别为左子节点和右子节点。二叉树的子树也是二叉树。
        2. 二叉搜索树（Binary Search Tree）：一种特殊的二叉树，它满足以下性质：
            对于任意节点，它的左子树中的所有节点的值都小于该节点的值，而右子树中的所有节点的值都大于该节点的值。
        3. 平衡树（Balanced Tree）：一种高度平衡的二叉搜索树，通过特定的平衡策略保持左右子树的高度差在可接受的范围内，以提高查询效率。
        4. 红黑树（Red-Black Tree）：一种自平衡的二叉搜索树，具有以下性质：每个节点都有一个颜色属性，要么是红色，要么是黑色；
            根节点和叶子节点（NIL节点）是黑色；如果一个节点是红色，则其子节点必须是黑色；从根节点到叶子节点的所有路径上，黑色节点的数量相同。
        5. B树（B-Tree）：一种平衡的多路搜索树，每个节点可以有多个子节点，适用于大规模数据存储和高效查找的场景。
        6. 堆（Heap）：一种完全二叉树结构，具有特定的堆序性质，用于高效地获取最大或最小元素。

    树的常见操作包括：
        1. 插入节点：将新节点插入到树中的适当位置，保持树的特定结构性质。
        2. 删除节点：从树中删除指定的节点，保持树的特定结构性质。
        3. 查找节点：在树中查找指定的节点，根据特定的搜索规则进行查找。
        4. 遍历树：按照一定的顺序访问树的所有节点，包括先序遍历、中序遍历、后序遍历和层次遍历等方法。

    树在计算机科学中具有广泛的应用，常见的用途包括：
        - 表示层次关系：如文件系统的目录结构、HTML标签的嵌套关系等。
        - 数据存储和搜索：如数据库的索引结构、字典树（Trie）等。
        - 算法和数据结构的实现：如优先队列、哈夫曼树、最小生成树等。

    什么是哈夫曼树：
        哈夫曼树（Huffman Tree），也称为最优二叉树（Optimal Binary Tree），是一种特殊的二叉树结构，常用于数据压缩和编码的算法中。
        它通过构建一棵具有最小带权路径长度的树，使得出现频率较高的字符具有较短的编码，而出现频率较低的字符具有较长的编码，从而实现高效的数据压缩。

        哈夫曼树的构建过程基于以下几个关键步骤：
            1. 频率统计：统计待编码的字符出现的频率，通常以字符为叶子节点，频率为权值。
            2. 构建森林：将每个字符作为一个独立的树（单节点树）加入到森林中。
            3. 合并节点：从森林中选择两个频率最低的树（权值最小的树），合并为一棵新的树，新树的权值为两个子树的权值之和。将新的树重新放入森林中。
            4. 重复合并：重复执行步骤3，直到森林中只剩下一棵树，即哈夫曼树。

        在构建过程中，频率较高的字符对应的树节点位于较低层，而频率较低的字符对应的树节点位于较高层，
        从而实现了编码长度的差异，使得频率较高的字符具有较短的编码，频率较低的字符具有较长的编码。

        哈夫曼树的应用广泛，特别是在数据压缩领域中，常用于无损压缩算法，如Huffman压缩算法。
        该算法利用哈夫曼树为不同字符分配唯一的二进制编码，以实现高效的数据压缩和解压缩。

    什么是最小二叉树：
        最小二叉树，也称为最小堆（Min Heap），是一种特殊的二叉树结构，其中每个节点的值都小于或等于其子节点的值。它具有以下特点：
            1. 完全二叉树：最小二叉树是一个完全二叉树，即除了最后一层的叶子节点可能不满外，其他层都是满的，且所有节点都向左侧靠拢。
            2. 堆性质：对于最小二叉树中的任意节点，其值都小于或等于其左子节点和右子节点的值。
        最小二叉树常常用于实现最小优先队列（Min Priority Queue）或堆排序算法。
            在最小优先队列中，根节点始终存储最小的值，可以快速获取最小值并删除。堆排序算法利用最小二叉树的特性进行排序，
            通过不断调整堆的结构，将最小值移至数组的首位，然后从剩余元素中选择最小值，重复该过程直到数组完全有序。

        最小二叉树的构建通常采用从上至下、从左至右的方式逐个插入元素的方法，即每次插入一个新元素时，
            将其放置在当前最后一个位置，然后根据堆性质进行上浮操作，即与父节点比较并交换，直到满足堆的性质。

        最小二叉树在算法和数据结构中具有重要的应用，常用于优先级队列、堆排序、图算法（如Dijkstra算法）等场景，
            能够高效地获取最小值，并在某些情况下提供快速的插入和删除操作。

    红黑树修改参数怎么修改：
        在红黑树中，修改节点的参数通常包括节点的值和节点的键（key）。修改节点的值是指更新节点存储的数据，而修改节点的键是指更新节点在红黑树中的位置。
        要修改红黑树节点的值，可以直接访问节点并更新节点存储的数据。例如，如果节点存储的是整数值，可以通过节点对象的方法或属性来修改节点的值。
        要修改红黑树节点的键，需要进行以下步骤：
            1. 首先，找到要修改的节点。可以使用查找算法（如二叉搜索树的查找）来定位目标节点。
            2. 修改节点的键需要涉及到树的结构变化。首先，从红黑树中删除目标节点，删除操作会涉及调整红黑树的平衡，确保删除后的树仍然满足红黑树的性质。
            3. 修改节点的键值。
            4. 将修改后的节点重新插入红黑树中，插入操作同样会涉及调整红黑树的平衡。

        需要注意的是，修改节点的键可能会导致树的结构发生变化，可能需要进行旋转操作或颜色调整来保持红黑树的平衡性和性质。


    什么是自平衡二叉树：
        自平衡二叉树（Self-Balancing Binary Tree）是一种二叉树数据结构，它通过特定的规则和算法来自动调整节点的位置，以保持树的平衡状态。
            平衡状态的维护可以确保在最坏情况下，树的高度保持较小，从而提高树的性能。

        在自平衡二叉树中，每个节点都有一个附加的平衡因子或高度差（balance factor），用于表示左子树和右子树的高度之差。
            常见的自平衡二叉树包括红黑树、AVL树、B树等。

        自平衡二叉树的特点是：
            1. 平衡因子的维护：对于每个节点，其左子树和右子树的高度差不能超过一个固定的阈值（通常为1），即平衡因子的绝对值不能大于1。
            2. 自动调整：当插入或删除节点导致树不再平衡时，自平衡二叉树会通过旋转、重新分配节点等操作来调整树的结构，使之重新达到平衡状态。

        自平衡二叉树的优点是能够在各种操作（如插入、删除、查找等）的过程中保持树的平衡，从而保证了操作的高效性和稳定性。
            然而，自平衡二叉树的调整操作可能会增加一些额外的开销，因此在某些场景下可能不适用。
            选择适合的数据结构需要根据具体的应用需求和数据访问模式进行权衡和选择。


6、哈希表
    哈希表（Hash Table），也称为散列表，是一种基于哈希函数（Hash Function）实现的数据结构。
    它通过将键（Key）映射到哈希值（Hash Value）来存储和检索数据。哈希表提供了高效的插入、删除和查找操作，使得在平均情况下，这些操作的时间复杂度为常数级别（O(1)）。

    哈希表的基本原理是将键映射到数组中的索引位置，通过数组的快速访问来实现高效的数据操作。具体的实现过程包括以下几个关键步骤：
        1. 哈希函数：哈希函数将键转换为哈希值，通常是一个整数。好的哈希函数应该具有以下特点：
           - 一致性：相同的键应该映射到相同的哈希值。
           - 均匀性：哈希值的分布应尽可能均匀，避免冲突。
        2. 数组存储：哈希表使用一个数组来存储数据。数组的长度通常根据数据规模和性能需求进行选择。
        3. 冲突处理：由于可能存在不同的键映射到相同的哈希值，即冲突（Collision），需要解决冲突的情况。常见的冲突处理方法有两种：
           - 链地址法（Chaining）：使用链表来解决冲突，将具有相同哈希值的键值对存储在同一个链表中。
           - 开放地址法（Open Addressing）：在哈希表的数组中找到下一个可用的空槽来存储冲突的键值对，常见的开放地址法包括线性探测、二次探测和双重哈希等。
        4. 插入操作：通过哈希函数计算键的哈希值，根据哈希值找到数组中对应的索引位置，并将键值对存储在该位置。如果发生冲突，根据冲突处理方法解决冲突。
        5. 查找操作：通过哈希函数计算键的哈希值，根据哈希值找到数组中对应的索引位置，然后在该位置的链表或数组中查找指定的键。
        6. 删除操作：根据键找到对应的索引位置，并从链表或数组中删除对应的键值对。

    哈希表的优点包括高效的插入、删除和查找操作，适用于大规模数据存储和高效查询的场景。然而，哈希表也存在一些限制和注意事项：
        - 冲突可能导致性能下降：如果哈希函数不好或者数据分布不均匀，冲突会增加，影响操作的效率。
        - 哈希表的空间消耗较高：为了减少冲突，哈希表需要保留一定的空闲槽位，导致空间利用率较低。
        - 哈希函数的选择：选择合适的哈希函数对于哈希表的性能至关重要，需要综合考虑键的特征和应用场景。

    在Java中，哈希表的常见实现包括HashMap、Hashtable和HashSet等。这些类提供了对键值对和唯一值的高效存储和检索功能。

        什么是哈希碰撞，如何解决：
            哈希碰撞（Hash Collision）是指不同的输入值经过哈希函数计算后得到相同的哈希值的情况。
            在哈希表或哈希算法中，哈希函数将输入值映射到哈希值的过程中，由于哈希函数的有限输出范围和输入的无限性，
            可能会导致不同的输入值得到相同的哈希值，这就是哈希碰撞的发生。
            哈希碰撞是一种常见的现象，尤其是当输入值的数量远远超过哈希函数的输出范围时，碰撞的概率会显著增加。
            哈希表等数据结构在处理哈希碰撞时需要采取一定的解决策略，以确保数据的正确性和高效性。

        常见的哈希碰撞解决策略包括：
            1. 链接法（Chaining）：使用链表或其他数据结构将哈希值相同的元素存储在同一个哈希桶中。
            2. 开放地址法（Open Addressing）：当发生哈希碰撞时，尝试在哈希表中找到另一个空闲的位置来存储冲突的元素，
                通常通过线性探测、二次探测、再哈希等方法来确定新的存储位置。
            3. 建立更好的哈希函数：设计更好的哈希函数可以降低哈希碰撞的概率，尽量使得不同的输入值得到不同的哈希值。
            4. 调整哈希表的大小：通过扩展哈希表的大小，可以增加哈希值的分布范围，从而降低哈希碰撞的概率。

7、图
    在数据结构中，图（Graph）是由节点（顶点）和边组成的一种非线性数据结构，用于描述事物之间的关系。
        图可以用来表示各种实际问题，如网络拓扑、社交网络、地图路线等。
    图由一组节点和连接这些节点的边组成。节点通常表示实体或对象，而边表示节点之间的关系。
        图可以分为有向图和无向图，具体取决于边是否具有方向。有向图中的边有明确的起点和终点，而无向图中的边没有方向。
    图的节点和边可以具有各种属性和权重。节点的属性可以是任意类型的数据，如标签、值或其他信息。
        边可以表示节点之间的关系，可以是无权边（没有权重或距离的边）或带权边（具有权重或距离的边）。

    图的常见表示方法有两种：邻接矩阵和邻接表。
        - 邻接矩阵：使用二维数组表示节点之间的关系。矩阵的行和列分别代表节点，矩阵中的元素表示节点之间的边的关系。邻接矩阵适用于表示稠密图，但对于稀疏图可能会浪费空间。
        - 邻接表：使用链表或数组的列表表示节点之间的关系。每个节点有一个与之相邻的节点列表，列表中存储了与该节点相连的边。邻接表适用于表示稀疏图，可以节省空间。

    图的常见操作包括：
        - 添加节点：向图中添加新的节点。
        - 添加边：在两个节点之间添加一条边，可以是有向边或无向边，带权或无权。
        - 删除节点：从图中删除指定的节点及其相关的边。
        - 删除边：从图中删除两个节点之间的边。
        - 遍历图：按照一定的顺序访问图中的所有节点和边。
        - 查找节点和边：根据指定的条件查找图中的节点和边。
        - 最短路径：查找两个节点之间的最短路径，可以使用广度优先搜索或Dijkstra算法等。
        - 最小生成树：找到一个连通图的最小生成树，常用的算法有Prim和Kruskal等。

    图是一种非常重要且广泛应用的数据结构，它能够有效地表示和解决各种实际问题。在图论中，有许多算法和技术用于处理图的特性和问题，
        包括图的遍历、最短路径、最小生成树、拓扑排序等，这些算法在计算机科学和相关领域中具有重要的应用价值。

    广度优先搜索：
        广度优先搜索（Breadth-First Search，简称BFS）是一种图遍历算法，用于在图或树的数据结构中从起始节点开始，逐层遍历其邻接节点，直到遍历完所有可达节点为止。

        BFS的遍历方式是逐层地遍历图中的节点，先访问起始节点，然后依次访问其邻接节点，再访问邻接节点的邻接节点，以此类推。具体的遍历过程如下：
            创建一个队列（通常使用先进先出的队列），将起始节点放入队列中。
            标记起始节点为已访问。
            当队列不为空时，执行以下步骤：
                从队列中取出一个节点，访问该节点。
                将该节点的所有未访问过的邻接节点加入队列，并标记为已访问。
            重复步骤3，直到队列为空。
        BFS的特点是以层级的方式进行遍历，先访问距离起始节点最近的节点，然后是第二层节点，第三层节点，依次类推。
        这样可以保证在同一层级的节点被完全访问之后，才会访问下一层级的节点。因此，BFS可以用于寻找最短路径、图的连通性判断、图的最小生成树等应用场景。


    深度优先搜索：
        深度优先搜索（Depth-First Search，简称DFS）是一种图遍历算法，用于在图或树的数据结构中从起始节点开始，
        尽可能深地访问其邻接节点，直到无法继续访问为止，然后回溯到上一个节点，继续访问其他未被访问的邻接节点。

        DFS的遍历方式是从起始节点开始，选择一个未被访问过的邻接节点进行访问，然后再以该邻接节点为起始节点，递归地继续进行深度优先搜索。具体的遍历过程如下：
        创建一个栈（通常使用后进先出的栈），将起始节点放入栈中。
            标记起始节点为已访问。
            当栈不为空时，执行以下步骤：
                从栈顶取出一个节点，访问该节点。
                将该节点的所有未访问过的邻接节点加入栈，并标记为已访问。
            重复步骤3，直到栈为空。
        DFS的特点是优先访问离起始节点最远的节点，逐渐深入到图的深处，直到无法继续访问为止。因此，DFS可以用于寻找路径、图的连通性判断、图的拓扑排序等应用场景。
