面向对象思想

    面向对象思想概述
        面向对象是基于面向过程的编程思想
        详情见面向对象概述

    面向对象开发
        就是不断的创建对象，使用对象，指挥对象做事情。
    面向对象设计
        其实就是在管理和维护对象之间的关系。
    面向对象特征
        封装(encapsulation)
        继承(inheritance)
        多态(polymorphism)

        封装（Encapsulation）：
            封装是面向对象编程的一种核心概念，它指的是将数据和对数据的操作封装在一个类中，以实现数据的隐藏和保护。
            通过封装，类的内部细节和实现方式对外部是不可见的，只有提供的公共接口（方法）可以被其他对象访问和使用。
            封装提供了数据的安全性和灵活性，使得对象的使用者只需关注对象的行为而不需要了解其内部实现细节。

        继承（Inheritance）：
            继承是面向对象编程中的一种机制，它允许一个类继承另一个类的属性和方法。
            继承通过创建新的类（子类）来继承现有类（父类）的特性，子类可以继承父类的属性和方法，
            并且可以在此基础上添加新的属性和方法，或者重写父类的方法。继承实现了代码的重用和扩展，提供了类之间的层次结构和关联。

        多态（Polymorphism）：
            多态是面向对象编程的一个重要特性，它允许不同类型的对象对同一消息做出不同的响应。
            多态性允许将父类类型的引用指向子类的对象，从而通过父类类型调用子类的方法。
            多态提供了一种灵活性和可扩展性的设计方式，使得代码可以更加通用和可复用。
            多态性通过继承和方法的重写实现，它能够根据对象的具体类型动态选择调用哪个方法，而不是在编译时确定。


类与对象及其使用

    类（Class）和对象（Object）是面向对象编程的两个核心概念，它们之间存在紧密的关系。
        1. 类（Class）：类是对一类对象的抽象描述。它定义了对象的属性（成员变量）和行为（成员方法）。
                        类可以看作是对象的模板或蓝图，它描述了对象应该有哪些属性和能够执行哪些操作。在Java中，类是通过class关键字来定义的。

        2. 对象（Object）：对象是类的实例化（实现）结果。它是类的具体实体，可以在内存中动态创建和销毁。
            每个对象都有自己的状态（即属性值）和行为（即方法调用）。对象可以看作是类的具体化，是类的一个实例。
            在Java中，通过使用`new`关键字来创建类的对象。

    关系：
        1. 类是对象的抽象，而对象是类的实例。
        2. 类定义了对象的结构和行为，对象具有类所描述的属性和方法。
        3. 通过创建对象，可以在内存中实例化一个类，并为其分配内存空间。
        4. 类可以看作是一种数据类型，而对象是该数据类型的具体值。
        5. 类是静态的，一旦定义就固定不变，而对象是动态的，可以根据类创建多个不同的实例。

    学生：
        属性：学号，姓名，年龄，性别
        行为：学习，吃饭
    属性---成员变量：在类中方法外定义，定义格式和之前一样，这里可以不用自己赋值
    行为---成员方法：和我们之前说的方法语句定义格式一样，只不过现在先把static去掉


属性和方法的用法：
    创建对象之后，对象名.属性  对象名.方法()


类在创建之后在方法区中的类方法区就会出现 方法名.class，其中包括该类的相关方法
    s1.name = “cyc”
    s1在栈中通过地址值找到堆内存中的成员变量进行赋值
    s1.study（） 栈---堆---类方法区(找到相应方法)---栈（执行）

数据类型：
        基本数据类型：byte,short,int,long,float,double,boolean,char
        引用数据类型：类、接口、数组、枚举、字符串、包装类


一个java程序运行过程：编写java文件.java --> .class(我们代码中每一个class类将来都会被编译成一个class文件)  --> 运行
 一个java文件中可以定义多个class类，但是只能有一个class类被public修饰，且要与java文件重名


成员变量和局部变量的区别
    成员变量和局部变量
        1、在类中的位置不同
            成员变量 类中方法外
            局部变量 方法内或者方法声明上
        2、在内存中的位置不同
            成员变量 堆内存
            局部变量 栈内存
        3、生命周期不同
            成员变量 随着对象的存在而存在，随着对象的消失而消失
            局部变量 随着方法的调用而存在，随着方法的调用完毕而消失
        4、初始化值不同
            成员变量 有默认的初始化值
            局部变量 没有默认的初始化值，必须先定义，赋值，才能使用。

        （在类中的位置不同到导致了在内存中出现的位置不同，进而也导致了生命周期不同）

形式参数问题
    基本类型作为形式参数

    引用类型作为形式参数
        当看到一个类作为方法的形式参数类型的时候，将来调用该方法时，需要传入该类的对象

匿名对象
    就是没有名字的对象。（对象的一种简化表示形式）

    匿名对象的两种使用情况
        1、对象调用方法仅仅使用一次的时候
        2、作为实际参数传递


同一个类中的方法可以直接相互调用，而不需要创建对象。
而一个类中的方法可以直接调用另一个类中的方法，但需要通过创建对象来访问其他类的方法。
                创建对象需要在方法中创建


封装
    概念：
        将对象的状态（属性）和行为（方法）包装在一个单一的单元（类）中，并对外部隐藏对象的具体实现细节。
    封装的目的：
        为了实现信息隐藏和保护对象的数据，使得对象的使用者只需要关心对象提供的公共接口，而不需要知道对象内部是如何实现的。
    好处：
        隐藏实现细节，提供公共的访问方式
        提高了代码的复用性
        提高安全性。
    封装原则：
        将不需要对外提供的内容都隐藏起来。
        把属性隐藏，提供公共方法对其访问。


    private关键字：
        是一个权限修饰符。可以修饰成员(成员变量、成员方法、构造方法) 被private修饰的成员只在本类中才能访问。

        private最常见的应用：
            把成员变量用private修饰
            提供对应的getXxx()/setXxx()方法
            一个标准的案例的使用
        private关键字修饰成员方法：
            如果一个类中的方法被private修饰，则这个方法将不能外界被调用，可以在类中再创建一个方法调用被private修饰的方法（间接调用）


    一个标准类的写法：
        一个1.0版本的类：通过setXxx  和 getXxx 方法设置和获取成员变量

        一个2.0版本的类（加上private关键字）：
        成员变量：必须使用private关键字修饰
        成员方法：必须提供成员变量对应的公共的setXxx()和getXxx()，特殊情况除外,show()方法展示所有的成员变量
            setXxx()和getXxx()用来操作成员变量，show()仅展示所有的成员变量值

        一个标准类的3.0写法，将形参的名字遵循见名知意思去定义，加入this关键字

        一个基本类的标4.0写法:
            成员变量
            构造方法
                无参构造方法
                带参构造方法
            成员方法
                getXxx()
                setXxx()
                .....
            重写toString方法


    变量的使用顺序:
        方法中使用变量，如果方法内部有该变量，就用方法内部的，如果方法内部找不到，就去成员变量上去找，如果成员变量上也没有，就报错
        我们之前在说变量的时候提到一个词：见名知意  变量的使用规则：就近原则


        this可以访问成员变量，构造方法，成员方法
        this.show() 等同于 show()


    this关键字:
        1、引用当前对象：
            在类的非静态方法中，可以使用 this 关键字来引用当前对象。通过 this，可以访问当前对象的成员变量和成员方法。
            例如，this.name 表示访问当前对象的 name 成员变量。
        2、区分同名的成员变量和局部变量：
            如果在方法或构造方法中存在与成员变量同名的局部变量，可以使用 this 关键字来区分它们。
            通过 this，可以明确指定访问的是成员变量而不是局部变量。例如，this.name 表示访问当前对象的成员变量 name，而 name 表示访问方法中的局部变量。
        3、从伪代码层面看面向过程和面向对象的思想调用其他构造方法：
            在一个构造方法中，可以使用 this 来调用同一个类中的其他构造方法。这种方式称为构造方法的重载。
            通过 this，可以避免重复的初始化代码，提高代码的复用性。例如，this(name, age) 表示调用带有 name 和 age 参数的构造方法。
        4、有了继承以后，我们定义一个类的时候，可以在一个已经存在的类的基础上，还可以定义自己的新成员。将当前对象作为参数传递：
            在方法调用中，可以使用 this 关键字将当前对象作为参数传递给其他方法。这样可以在方法之间传递对象，实现对象之间的交互和数据共享。
        5、类名.this表示当前类的实例

        this注意事项：
            在Java的main方法中，不能使用this关键字。
            this关键字指向当前对象实例，而在main方法中是静态方法，没有隐式的当前对象实例，因此无法使用this关键字。
            this关键字只能在非静态方法中使用，用于引用当前对象的实例成员。
            在继承中使用 this 关键字访问成员时，优先在当前类中查找，找不到再去父类中查找。


    构造方法:

        每次在对象创建时都会被调用，对对象的数据进行初始化

        语句定义格式：
            方法名和类名一致，没有返回值类型，连void都不能有

        快捷键: Alt+insert 选择构造方法 setXxx()和getXxx()

        注意事项：
            1、如果我们不提供构造方法，那么java会自动提供一个公共的无参无方法体的构造方法
            2、如果我们自己提供了构造方法，那么系统将不再提供任何构造方法
            3、方法在同一个类中可以发生重载，构造方法也可以发生重载
            4、构造方法的第二个使用方式：给成员变量进行赋值
            5、没有返回值类型，连void都没有，没有return

    类的成员方法：
        根据返回值：
            有明确返回值方法
            返回void类型的方法
        根据形式参数：
            无参方法
            带参方法

        给成员变量赋值的方式：
            无参构造方法+setXxx()
            带参构造方法

    类的初始化：
        类的初始化是指在创建类的对象时，为对象的成员变量赋予初始值的过程
            过程:
                加载Student.class文件进内存
                在栈内存为s开辟空间
                在堆内存为学生对象开辟空间
                对学生对象的成员变量进行默认初始化
                对学生对象的成员变量进行显示初始化
                通过构造方法对学生对象的成员变量赋值
                学生对象初始化完毕，把对象地址赋值给s变量

    static(静态的)：
            可以修饰成员变量和成员方法

        static关键字特点
            1）随着类的加载而加载
            2）优先于对象存在
            3）被类的所有对象共享
                这也是我们判断是否使用静态关键字的条件
            可以通过类名调用

        static关键字注意事项
            在静态方法中是没有this关键字的
                如：this关键字指向当前对象实例，而在main方法中是静态方法，没有隐式的当前对象实例，因此无法使用this关键字
            静态方法只能访问静态的成员变量和静态的成员方法

        静态static修饰成员的特点：
        1、随着类的加载而被加载到方法区中静态区，优先于对象存在，被类的所有对象共享（这也是我们判断是否使用静态关键字的条件）
        2、将来可以直接通过   类名.静态成员  类名.静态方法   静态的成员既可以使用类名直接调用，也可以使用类的对象进行调用，推荐直接使用类名调用
        3、静态的成员方法只能访问静态的成员(成员变量或者成员方法)
        4、非静态的成员方法既可以访问静态的成员也可以访问非静态的成员
        5、在静态方法中是没有this关键字的
        6、被static修饰的成员变量，表示被所有的该类的对象共享

        静态的内容存在于方法区的静态区


    静态变量和成员变量的区别
        所属不同
            静态变量属于类，所以也称为为类变量
            成员变量属于对象，所以也称为实例变量(对象变量)
        内存中位置不同
            静态变量存储于方法区的静态区
            成员变量存储于堆内存
        内存出现时间不同
            静态变量随着类的加载而加载，随着类的消失而消失
            成员变量随着对象的创建而存在，随着对象的消失而消失
        调用不同
            静态变量可以通过类名调用，也可以通过对象调用
            成员变量只能通过对象名调用

    制作帮助文档：

        制作工具类
            ArrayTools
        制作帮助文档(API)
            javadoc -d 目录 -author -version ArrayTool.java
        制作帮助文档的注意事项：
            1、构造方法私有化
            2、成员方法必须是静态的
                这样调用工具类方法的时候就直接使用     工具类名.方法(参数类型 参数名)


        如何使用帮助文档：
            A:找到文档，打开文档。
            B:点击左上角的显示变成隐藏，然后点击索引
            C:你应该知道你要找谁?Math
                所以，你就在那个输入框里面输入Math，然后回车，再回车。
            D:看这个类的结构
                java.lang
                    类 Math
                java.util
                    类 Scanner
                如果是java.lang包下的类，是可以直接使用的。(Math)
                否则，就需要导包才能使用。(Scanner)
            E:看看对这个类的说明。
            F:看构造方法
                名称：字段	--	成员变量	-- 属性。

                a:有构造方法，那么，就通过构造方法创建对象使用。
                b:没有构造方法，那么，这个类的成员一般都是静态。
                通过类名调用。
            G:按照正常的操作使用方法。
                左边：
                    是否静态：如果静态修饰，那么可以通过类名调用。否则，就必须创建对象调用。
                    是否有明确返回值：如果是void类型，就直接调用即可。否则，就可以输出或者赋值。
                右边：
                    看方法名：不要写错了。
                    看参数：看参数类型及个数。

    代码块：
        在Java中，使用{}括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。

        局部代码块：
            就是在方法内部定义代码块，叫做局部代码块，就是使用一个大括号括起来
            作用：限定变量的生命周期，作用域

        构造代码块：
            在类中方法外定义，也是由大括号括起来的代码块
            执行顺序：构造方法--构造代码块（若存在多个构造代码块，多个构造代码块之间会自上而下执行）
            作用：放到继承的时候讲解

        静态代码块：
            在类中方法外定义，不仅使用大括号括起来，且在最开始使用static修饰,优先于对象

        执行顺序：静态代码块--构造代码块--构造方法（若存在多个构造代码块，多个构造代码块之间会自上而下执行）
            注意：静态代码块只会在程序运行的最开始执行一次，后续不会执行了。
            父类静态--子类静态--父类构造代码块--父类构造方法--子类构造代码块--子类构造方法


继承
    继承概述
        1、多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。
        2、通过extends关键字可以实现类与类的继承
            class 子类名 extends 父类名 {}
        3、单独的这个类称为父类，基类或者超类；这多个类可以称为子类或者派生类。
        4、有了继承以后，我们定义一个类的时候，可以在一个已经存在的类的基础上，还可以定义自己的新成员。

    1、继承的好处：
        提高了代码的复用性
            多个类相同的成员可以放到同一个类中
        提高了代码的维护性
            如果功能的代码需要修改，修改一处即可
        让类与类之间产生了关系，是多态的前提
            其实这也是继承的一个弊端：类的耦合性很强
                将来的开发的原则：低耦合，高内聚
    2、继承的特点：
        1）java中类与类之间不允许多继承（不允许一个类同时继承多个类），只允许单继承
            class SubDemo extends Demo{} //ok
            class SubDemo extends Demo1,Demo2...//error

        2）java允许多层继承，形成一个继承体系
            class A{}
            class B extends A{}
            class C extends B{}


    使用继承的注意事项：
        1、子类只能继承父类的非私有的成员 （其实这也体现了继承的另一个弊端：打破了封装性）
        2、父类的构造方法无法被子类所继承，但是可以被使用，要想初始化子类，必须先初始化父类。
            （也就是在执行子类构造方法之前先执行父类构造方法）初始化包括父类属性的初始化，构造代码块初始化，构造方法初始化
        3、不要为了部分功能而去继承
            那么什么时候使用继承？ 只要满足英语的”is a“这个语法，就可以使用(什么是什么，例：苹果是水果)
        4、被static修饰的父类不能算被子类继承
        5、在继承中使用 this 关键字访问成员时，优先在当前类中查找，找不到再去父类中查找。

    继承中成员变量的关系：
        子类使用变量的顺序：(就近原则)
            先在当前方法内部查找，如果找到就使用，否则去当前类的成员变量位置上查找，如果找到就使用，否则最终会去父类的成员变量位置上找。
        子类无法调用父类方法里的变量
        想获取父类中的变量：
            1、在子类中创建父类的对象调用父类中的成员变量
                Fu fu = new Fu();
                fu.a;
            2、使用super直接引用父类的成员变量
                super.a;


    super关键字：代表的是直接父类的引用，将来可以通过super关键字调用直接父类中的成员
        类：
            成员变量：super.成员变量名
            成员方法：super.成员方法名(...)
            构造方法：子类的构造方法第一句话默认存在一个super()

        1、对父类做初始化，代码层面其实就是调用父类的构造方法就行了，无论是无参还是有参
        2、父类不能进行多次初始化
        3、子类中的super关键字只能代表父类的引用，不能跨继承使用

        super 关键字的使用场景和作用包括以下几个方面：
            1、访问父类的成员变量：通过 super.成员变量名 的方式，可以访问父类中被隐藏的成员变量。
                这在子类中存在与父类同名的成员变量时特别有用。
            2、调用父类的成员方法：通过 super.成员方法名() 的方式，可以调用父类中被子类重写的成员方法。
                这样可以在子类中扩展父类的方法逻辑，同时保留父类原有的功能。
            3、调用父类的构造方法：通过 super(...) 的方式，可以在子类的构造方法中调用父类的构造方法。
                这样可以实现子类构造方法的初始化，并且确保父类的构造方法也被执行。

    使用 super 关键字时需要注意以下几点：
        1、在子类的成员方法中使用 super 关键字，可以直接访问父类的成员变量和成员方法。
        2、在子类的构造方法中使用 super 关键字，必须在构造方法的第一行调用父类的构造方法。
        3、如果子类的构造方法没有显式调用父类的构造方法，编译器会默认插入一个无参的 super() 调用。
        4、子类可以通过 super 关键字来访问父类的构造方法，并传递参数，以完成对父类成员变量的初始化。
        5、只能代指子类的父类，不能调用父类的父类
        总之，super 关键字提供了一种方便访问父类成员的方式，可以在子类中扩展和复用父类的功能，并且通过调用父类的构造方法实现对父类成员变量的初始化。


    super和this：

        this关键字代表调用该方法的当前对象，super代表父类的引用
        this关键字用作用在本类当中，super关键字作用在继承中
        this 关键字只能用于访问当前对象的成员，而 super 关键字可以用于访问当前对象的父类的成员。
        使用 this 关键字访问成员时，优先在当前类中查找，找不到再去父类中查找。使用 super 关键字访问成员时，直接去父类中查找

        在静态方法中，无法使用关键字 this 和 super。
            this 关键字代表当前对象的引用，而静态方法属于类本身而不是对象实例，因此无法在静态方法中引用 this。
            super 关键字用于访问父类的成员，但静态方法没有实例对象，也没有继承关系的概念，所以无法在静态方法中使用 super 关键字来调用父类的成员。


    继承中类的初始化：
        子类初始化之前，一定要先完成父类数据的初始化
        无论是有参还是无参只要能调用父类的构造方法完成初始化即可，且只能初始化一次

    继承中构造方法的关系：
        1、子类中所有的构造方法默认都会访问父类中空参数的构造方法
        2、子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。
        3、子类调用成员方法，会先在当前子类中查找，如果子类中找不到，就去父类中找，如果父类中都没有，那么就报错。
            每一个构造方法的第一条语句默认都是：super()
        4、如果父类中没有构造方法，该怎么办呢?
            子类通过super去显示调用父类其他的带参的构造方法
            子类通过this去调用本类的其他构造方法
                本类其他构造也必须首先访问了父类构造
            一定要注意：
                super(…)或者this(….)必须出现在第一条语句中
                否则，就会有父类数据的多次初始化

    方法的重写：
        当子类中的方法声明与父类中的方法声明（返回值类型，方法名，参数列表）一模一样，但是方法的实现却不同，这个现象：方法的重写
        如果涉及到方法的重写，请在子类重写的方法上面加上一个注解@Override

        重写的注意事项：
            1）子类重写父类方法的时候，权限修饰符不能比父类的还要低，建议：子类重写的权限修饰符和父类保持一致
                权限修饰符从宽到严排列：public(公共的)--protected(受保护的)--默认--private(私有的)
            2）父类私有的成员方法无法被继承更无法被重写
            3）父类的静态成员方法，无法被子类继承重写，但是经测试发现，子类对象可以使用
            解释：
                由于静态方法与类相关而不是与对象相关，所以它们不具有多态性，也就是说子类无法重写父类的静态方法。
                当子类定义了与父类同名的静态方法时，实际上是在隐藏（shadowing）父类的静态方法，并不是重写。
                尽管子类无法重写静态方法，但它们仍然可以通过继承来获得静态方法。
                子类可以直接调用父类的静态方法，也可以通过子类的实例来调用父类的静态方法。
                这是因为静态方法在类加载时就已经存在于内存中，并且与类本身相关联

        方法重写和方法重载的区别？
            定义：
                方法重写指的是在子类中定义一个与父类中具有相同名称、参数列表和返回类型的方法，以覆盖（重写）父类中的方法。
                方法重载指的是在一个类中定义多个方法，它们具有相同的名称但参数列表不同。
            关联对象：
                方法重写发生在继承关系中，即子类继承父类，并在子类中对父类的方法进行重写。
                方法重载发生在同一个类中，通过在同一个类中定义多个方法来实现。
            参数列表：
                方法重写的方法签名（包括参数列表）必须与父类中被重写的方法完全一致。
                方法重载的方法签名必须不同，可以有不同的参数类型、参数个数或参数顺序。
            返回类型：
                方法重写的返回类型必须与父类中被重写的方法相同或是其子类型（协变类型）。
                方法重载可以有相同或不同的返回类型，只要其他方法签名不同即可。
            功能：
                方法重写用于实现多态性，子类可以通过重写父类的方法来提供自己特定的实现。
                方法重载用于实现同一操作的不同版本，可以根据不同的参数类型或参数个数来选择不同的方法。

        方法重载能改变返回值类型吗?
            在方法重载中，可以在同一个类中定义多个具有相同名称但参数列表不同的方法，包括返回值类型。
            编译器会根据方法调用时传递的参数类型来选择匹配的方法。
            例：
                public class MyClass {
                    public int add(int a, int b) {
                        return a + b;
                    }

                    public double add(double a, double b) {
                        return a + b;
                    }
                }

    final:  如果父类中某一个非私有的方法只想被子类继承使用，而不能被子类重写,java提供了一个关键字给我们使用，这个关键字：final
        final可以修饰哪些成员：
            成员方法：修饰成员方法，方法不能被子类重写，但仍然可以被子类继承和调用
            类：修饰类，类不能被继承
            变量：修饰基本数据类型变量，变量的值不能被修改，被final修饰的变量叫做自定义常量
                  若修饰的是引用数据类型，表示变量的地址值不能被改，但引用值可以变

        final修饰变量的初始化时机(什么时候给final修饰的变量赋值)
            在构造方法完毕之前给值，建议，在创建的时候就给值。

多态：
    多种状态，某一个事物在不同时刻下表现的不同状态
        水：固态 气态 液态
        水果：苹果 西瓜 桃子
        动物：狗 猫 猪

    在面向对象编程中
        子类的对象可以被赋给父类的引用变量，通过父类的引用变量可以调用子类重写的方法，实现不同的行为。这种特性被称为多态
        在多态中，子类对象可以被视为父类对象，这样就可以通过父类类型的引用变量来操作子类对象，而不需要关心具体的子类类型。
        这种灵活性和可扩展性使得代码更加通用和可维护。
        通过多态的特性，我们可以将不同子类的对象统一看待，并使用共同的方法来调用它们的行为

    多态的前提：
        1、要有继承关系
        2、要有方法的重写，不重写也可以，但是体现不出事物的特性
        3、要有父类的引用指向子类对象

    多态访问成员的特点：
        成员变量：多态访问成员变量，编译看左，运行看左
        成员方法：多态访问成员方法，编译看左，运行看右
        静态的成员方法：多态访问静态成员方法，编译看左，运行看左

        编译看左，运行看左  解释：
            编译阶段根据引用变量的类型（左边）来确定可访问的成员变量 运行阶段则仍然使用引用变量指向的对象的类型（左边）来确定实际访问的成员变量

    多态的好处
        提高了程序的维护性(由继承保证)
            通过多态性，可以将程序中的通用功能定义在父类中，而具体的实现可以放在各个子类中。
            这样，如果需要修改某个功能，只需修改父类中的代码，而不需要修改所有子类的代码。这提高了程序的维护性，减少了修改的工作量和风险

        提高了程序的扩展性(由多态保证)

    当父类中没有调用时的方法的时候，就会报错，如何解决？
        多态的弊端：无法使用子类中特有的方法
        解决方案：向下转型
        语句格式：目标类型 新变量名 = (目标类型)(要转的对象)
        注意向上向下转型只能发生在继承中

    向上转型和向下转型：
        向上转型（Upcasting）是指将子类对象赋给父类引用变量的过程，可以自动进行
            父类类型 引用变量 = new 子类对象;
        向下转型（Downcasting）是指将父类引用变量转换为子类类型的过程，需要进行强制类型转换
            子类类型 引用变量 = (子类类型) 父类引用变量;

抽象类：
    abstract：
        abstract可以修饰类，方法
            类：修饰类，类称之为抽象类
            方法；修饰方法，方法称之为抽象方法

    注意事项：
        1、当一个类中存在抽象方法的时候，这个类也必须被定义成抽象类
        2、抽象类中也可以存在具体实现的方法
        3、抽象类无法被实例化
        4、抽象类可以存在构造方法（目的是什么？为了在继承关系中提供初始化的功能）
        5、当一个具体的类继承一个抽象类的时候，必须要实现抽象类的 所有  抽象  方法
        6、抽象类可以继承一个抽象类，可以选择重写或不重写抽象方法
        7、抽象类中既可以存在变量，也可以存在常量


    抽象方法在抽象类或接口中声明时没有方法体（大括号）。它只包含方法的声明，指定了方法的名称、参数列表和返回类型，但没有具体的实现代码。
    子类继承抽象类后，必须实现（重写）抽象类中的抽象方法。
    当一个类继承了一个抽象类，它必须提供实现抽象类中的所有抽象方法的具体实现，否则该类也必须声明为抽象类。


    抽象类能被实例化吗？
        抽象类不能被直接实例化。抽象类是用来被继承的，它只能作为父类被其他类继承，并且子类需要实现抽象类中的抽象方法。
        抽象类本身是不完整的，它的目的是为了提供一个共同的模板或者规范，供子类去实现和扩展。


    一个类如果没有抽象方法，可不可以定义为抽象类?如果可以，有什么意义?
            没有抽象方法，定义一个抽象类仍然可以有意义。
            抽象类可以作为其他类的基类，提供一些通用的属性和方法。即使它没有抽象方法，它仍然可以包含非抽象的方法和成员变量，这些可以被子类继承和使用
        abstract class A{}

    abstract不能和哪些关键字共存
            private	冲突
                abstract关键字用于修饰类、方法或接口，表示这个类、方法或接口是抽象的，需要子类去实现或继承。
                而private关键字用于修饰类的成员（字段和方法），表示这个成员只能在当前类内部访问，对外部是不可见的。
                由于抽象方法和抽象类需要子类去实现或继承，而private关键字限制了成员的访问权限，使得该成员对子类是不可见的。
                这样一来，如果在抽象类中定义了一个私有的抽象方法，子类就无法访问该方法，也无法实现或继承该方法，从而违背了抽象类的设计初衷
            final	冲突   final类不能被继承，final方法不能被重写，final变量不能被修改    abstract目的就是让子类去继承
            static	无意义  抽象方法需要被子类实现或覆盖，它是针对实例的。而静态方法是属于类的，与具体的实例无关


接口：
    是类额外特殊拥有的功能，可以将其功能定义成接口，将来某些类若想要拥有特殊的功能，实现该接口即可
    定义接口关键字：interface

    定义接口时候的注意事项：
        1、接口中只能存在抽象方法, 默认会在抽象方法的定义前面添加public abstract修饰
        2、接口其实可以被看作成是一个特殊的类，将来也会被编译成一个class文件
        3、当一个具体的类实现接口的时候，使用implements关键字进行实现，并且要实现接口中的所有抽象方法
        4、一个具体的类在继承一个类的同时可以实现多个接口
        5、接口中只允许出现常量，而且默认会添加public static final修饰
        6、接口里不允许有构造方法，进而导致接口无法被实例化，只能被实现
        7、当一个抽象类实现一个接口的时候，可以选择或不去实现接口中的抽象方法


    接口如何实例化：
        按照多态的方式，由具体的子类实例化。其实这也是多态的一种，接口多态。


    接口的子类
        要么是抽象类
            当一个抽象类实现一个接口的时候，可以选择或不去实现接口中的抽象方法
        要么重写接口中的所有抽象方法
            在这里接口和抽象类相似



类与类,类与接口以及接口与接口的关系：
    类与类
        继承关系，只能单继承，但是可以多层继承
    类与接口
        实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时实现多个接口
    接口与接口
        继承关系，可以单继承，也可以多继承


抽象类和接口的区别:
    成员区别
        抽象类 变量,常量;有抽象方法;抽象方法,非抽象方法
        接口 常量(被final修饰的变量);抽象方法
    关系区别
        类与类  继承，单继承
        类与接口  实现，单实现，多实现
        接口与接口  继承，单继承，多继承
    设计理念区别
        抽象类 被继承体现的是：”is a”的关系。共性功能
        接口 被实现体现的是：”like a”的关系。扩展功能



一共学了三个多态：

    类与类的多态
    抽象多态
    接口多态




形式参数：
    基本类型：当你看到方法的参数类型是基本数据类型的，将来调用方法传入的是对应具体的数值
    引用类型：
        类：当你看到一个类作为方法的形式参数的时候，将来调用时需要传入该类或者该类的子类对象
            抽象类：当你看到一个抽象类作为方法的形式参数类型的时候，将来调用时需要传入该抽象类的具体子类对象
        接口：当你看到一个接口作为方法的形式参数类型的时候，将来调用时需要传入实现该接口的子类对象


返回值类型：
    基本数据类型：当基本数据类型作为方法的返回值类型的时候，return返回的是具体的数值
    引用数据类型：
        类：当类作为方法的返回值类型的时候，返回的是该类或者该类的子类对象
        抽象类：当你看到一个抽象类作为方法的返回值类型的时候，return返回的是该类的具体子类的对象
        接口：当你看到一个接口作为方法的返回值类型的时候，return返回的是该接口的具体实现子类对象。

链式调用：调用完方法后还可以调用其他方法

包：
    包的划分：
        1、按照功能划分
        2、按照模块（角色）划分

    导包格式：
        import 包名;
        *表示导入该目录下的所有类

权限修饰符：
        public : 都可以访问
        protected : 不同包的非子类不能访问
        默认 : 同包可以访问
        private : 只能在同一类中访问

    目前所学习过的修饰符：
        1、权限修饰符：public protected 默认的 private
        2、静态修饰符：static
        3、最终修饰符：final
        4、抽象修饰符：abstract

内部类：顾名思义就是在类中创建一个类
    根据定义的位置不同，分为两种：
        1、成员内部类：将一个类定义在成员位置上
            创建成员内部类的语句定义格式：
                外部类名.内部类名 对象名 = new 外部类名().new 内部类名();

            成员内部类可以被static修饰，内部的方法既可以是静态的，也可以是非静态的
                其中无论是静态方法还是非静态方法只能访问静态成员
            而非静态内部类中的方法不能是静态的，其非静态方法既可以访问静态也能访问非静态

            如果成员内部类是静态的话，又如何创建内部类的对象：
                外部类名.内部类名 对象名 = new 外部类名.内部类名();

            成员内部类也可以被private修饰

        2、局部内部类：将一个类定义在方法内部中
            如果一个方法内部有局部内部类，方法内部定义的变量默认会加上final关键字
            使用方法：
                直接创建一个外部类的对象调用局部内部类所在的方法

        内部类和外部类没有继承关系
